<style>
  b,span{display:inline-block;min-width:200px}
</style>
<body>
  <button onclick=dotest()>test</button>
<pre></pre></body>
<script src=db.min.js></script>
<script>

var 
  maxval = 1000,
  recsize = 20, 
  reccount = 5 * 1000, 
  keylist = {}, key, 
  toInsert = [], 
  logged = [],
  cutoff = maxval / 2;

// We try to insert a large amount of evenly distributed schema-free data


// poor programmers random number generator from primes is p1 * p2 * c % p3
// We use this method to control the data to make sure that every test run
// inserts the same data
var rand = (function() {
  var largePrimes = [
      [99497, 72727, 61463, 24469,100747, 90059, 55903, 40351, 19447, 12553],
      [12647, 40559, 35251, 27031, 38821, 65101, 51197, 84377, 21017, 19319],
      [84811, 79777,100291,  1933, 15199, 24509, 31607, 48049, 55511, 65267]
    ],
    round = 0,
    fallover = 500,
    lastrand = 100,
    p1,
    p2;

  return function(){
    if(round++ % fallover == 0) {
      p1 = largePrimes[0][Math.floor(round / fallover / 10) % 10]; 
      p2 = largePrimes[1][Math.floor(round / fallover) % 10]; 
      lastrand = largePrimes[2][Math.floor(round / fallover) % 10];
    }

    lastrand = (lastrand * p1 + round) % p2;
    return lastrand / p2;
  }
})();

function log(str) {
  logged.push(str);
}

var perfCheck = (function(){
  var timeList = [], roundTotal = 0, message;
  var pub = function (callback) {
    var ret, round;

    start = new Date();
    ret = callback() || '';
    end = new Date();


    round =  end.getTime() - start.getTime();
    roundTotal += round;
    timeList.push(round);

    return ret; 
  }
  pub.compute = function(message){
    var 
      roundCount = timeList.length,
      variance = 0,
      stddiv,
      mean = roundTotal / roundCount;
  
    variance = 0;
    for(var ix = 0; ix < roundCount; ix++) {
      variance += Math.pow(timeList[ix] - mean, 2);
    }
    variance /= roundCount;

    stddiv = Math.sqrt(variance);


    log([
      '<b title="' + timeList.join(',') + '">' + message + '</b>',
      '<span> ' + (roundTotal / roundCount) + '</span>',
      '<span> ' + stddiv + '</span>'
    ].join(''));

    pub.total += roundTotal;
    timeList = [];
    roundTotal = 0;
  }
  pub.total = 0;
  return pub;

})();

function makeKey(num) {
  return ((num + 4) * 1000).toString(36);
}

var value;
for(var ix = 0; ix < reccount; ix++) {
  toInsert[ix] = {};
  for(var iy = 0; iy < recsize; iy++) {
    do { 
      key = makeKey(Math.floor(rand() * (recsize * 4)));
    } while(key in toInsert[ix]);

    if(!keylist[key]) {
      keylist[key] = {low:0, high:0};
    }

    value = Math.floor(rand() * maxval);
    if(value < cutoff) {
      keylist[key].low++;
    } else {
      keylist[key].high++;
    }

    toInsert[ix][key] = value;
  }
}

function validate(t1, t2) {
  if(t1 != t2) {
    console.log (" fail (" + t1 + " != " + t2 + ")");
  }
}

var db;
function dotest() {
  var res;

  perfCheck.total = 0;

  perfCheck(function(){ db = DB(); });
  perfCheck.compute('initializing');

  perfCheck(function(){ res = db.insert(toInsert); });
  perfCheck.compute('inserting ' + reccount + ' records');

  perfCheck(function(){ res = db.find(); });
  perfCheck.compute('empty find');

  perfCheck(function(){ res = db.find().select('*'); });
  perfCheck.compute('empty find select of *');

  for(var key in keylist) {
    perfCheck(function(){ res = db.find().select(key); });
  }
  perfCheck.compute('empty find select of key');

  for(var key in keylist) {
    perfCheck(function(){ res = db.find(db(key, ' < ' + cutoff)); });
  }
  perfCheck.compute('find value < ' + cutoff);

  for(var key in keylist) {
    perfCheck(function(){ res = db.find(db.isin(key, [3, 9, 11, 12])); });
  }
  perfCheck.compute('indexof set find');

  for(var key in keylist) {
    perfCheck(function(){
      var len = toInsert.length, res = toInsert.slice(), x,
          spliceix,
          end = len;

      for(var ix = len - 1; ix > -1; ix--) {
        x = res[ix][key];
        if (x === 3 || x === 9 || x === 11 || x === 12) {
          
          spliceix = ix + 1;
          res.splice(spliceix, end - spliceix);
          end = ix;
        }
      }
      spliceix = ix + 1;

      if(end - spliceix > 0) {
        res.splice(spliceix, end - spliceix);
      }
      return res.length;
    });
  }
  perfCheck.compute('native set find ');


  log("Total of all tests: " + perfCheck.total + 'ms');
  document.body.getElementsByTagName('pre')[0].innerHTML = '<div>' + logged.join('</div><div>') + '</div>';
}
</script>
